<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/calculate_vespa_properties.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/calculate_vespa_properties.py" />
              <option name="updatedContent" value="import pandas as pd&#10;from Bio.SeqUtils.ProtParam import ProteinAnalysis&#10;import os&#10;import argparse&#10;&#10;class VespaPropertiesCalculator:&#10;    def __init__(self):&#10;        self.hydrophobic_aa = set(['A', 'V', 'I', 'L', 'M', 'F', 'Y', 'W'])&#10;        self.hydrophilic_aa = set(['R', 'K', 'D', 'E', 'Q', 'N', 'H', 'S', 'T', 'G', 'P', 'C'])&#10;        self.positively_charged_aa = set(['R', 'K', 'H'])&#10;        self.negatively_charged_aa = set(['D', 'E'])&#10;&#10;    def calculate_amphipathicity(self, sequence):&#10;        &quot;&quot;&quot;计算两亲性指数&quot;&quot;&quot;&#10;        hydrophobic_count = sum(1 for aa in sequence if aa in self.hydrophobic_aa)&#10;        hydrophilic_count = sum(1 for aa in sequence if aa in self.hydrophilic_aa)&#10;        total_count = len(sequence)&#10;        if total_count == 0:&#10;            return 0&#10;        hydrophobic_ratio = hydrophobic_count / total_count&#10;        hydrophilic_ratio = hydrophilic_count / total_count&#10;        if hydrophobic_ratio + hydrophilic_ratio == 0:&#10;            return 0&#10;        amphipathicity = 2 * hydrophobic_ratio * hydrophilic_ratio / (hydrophobic_ratio + hydrophilic_ratio)&#10;        return amphipathicity&#10;&#10;    def calculate_net_charge_at_ph(self, sequence, ph=7.4):&#10;        &quot;&quot;&quot;计算在指定pH下的净电荷&quot;&quot;&quot;&#10;        try:&#10;            protein_analysis = ProteinAnalysis(sequence)&#10;            net_charge = protein_analysis.charge_at_pH(ph)&#10;            return net_charge&#10;        except Exception as e:&#10;            print(f&quot;Error calculating charge for sequence {sequence}: {e}&quot;)&#10;            return 0&#10;&#10;    def calculate_additional_properties(self, sequence):&#10;        &quot;&quot;&quot;计算额外的理化性质&quot;&quot;&quot;&#10;        try:&#10;            protein_analysis = ProteinAnalysis(sequence)&#10;            properties = {&#10;                'molecular_weight': protein_analysis.molecular_weight(),&#10;                'aromaticity': protein_analysis.aromaticity(),&#10;                'instability_index': protein_analysis.instability_index(),&#10;                'isoelectric_point': protein_analysis.isoelectric_point(),&#10;                'gravy': protein_analysis.gravy(),&#10;                'helix_fraction': protein_analysis.secondary_structure_fraction()[0],&#10;                'turn_fraction': protein_analysis.secondary_structure_fraction()[1],&#10;                'sheet_fraction': protein_analysis.secondary_structure_fraction()[2]&#10;            }&#10;            return properties&#10;        except Exception as e:&#10;            print(f&quot;Error calculating properties for sequence {sequence}: {e}&quot;)&#10;            return {&#10;                'molecular_weight': 0,&#10;                'aromaticity': 0,&#10;                'instability_index': 0,&#10;                'isoelectric_point': 0,&#10;                'gravy': 0,&#10;                'helix_fraction': 0,&#10;                'turn_fraction': 0,&#10;                'sheet_fraction': 0&#10;            }&#10;&#10;    def calculate_all_properties(self, input_file, output_file=None, ph=7.4):&#10;        &quot;&quot;&quot;计算所有序列的理化性质，不进行筛选&quot;&quot;&quot;&#10;        if not os.path.exists(input_file):&#10;            print(f&quot;输入文件 {input_file} 不存在&quot;)&#10;            return None&#10;&#10;        # 读取CSV文件，使用分号作为分隔符&#10;        df = pd.read_csv(input_file, sep=';')&#10;        &#10;        if 'sequence' not in df.columns:&#10;            print(&quot;输入文件中没有找到序列列，请确保列名为'sequence'&quot;)&#10;            return None&#10;&#10;        print(f&quot;开始计算，共有 {len(df)} 个序列&quot;)&#10;&#10;        results = []&#10;&#10;        for idx, row in df.iterrows():&#10;            sequence = str(row['sequence']).strip().upper()&#10;            if not sequence or not sequence.isalpha():&#10;                print(f&quot;跳过无效序列: {sequence}&quot;)&#10;                continue&#10;&#10;            print(f&quot;正在处理序列 {idx+1}/{len(df)}: {sequence}&quot;)&#10;&#10;            # 计算基本属性&#10;            length = len(sequence)&#10;            amphipathicity = self.calculate_amphipathicity(sequence)&#10;            net_charge = self.calculate_net_charge_at_ph(sequence, ph)&#10;            &#10;            # 计算额外理化性质&#10;            additional_props = self.calculate_additional_properties(sequence)&#10;            &#10;            # 构建结果字典&#10;            result = {&#10;                'sequence': sequence,&#10;                'length': length,&#10;                'amphipathicity': amphipathicity,&#10;                'net_charge_ph7.4': net_charge,&#10;            }&#10;            &#10;            # 添加原始数据的其他列&#10;            for col in df.columns:&#10;                if col != 'sequence' and col not in result:&#10;                    result[col] = row[col]&#10;            &#10;            # 添加计算的理化性质&#10;            result.update(additional_props)&#10;            &#10;            results.append(result)&#10;&#10;        if results:&#10;            results_df = pd.DataFrame(results)&#10;            print(f&quot;\n计算完成！共处理了 {len(results_df)} 个有效序列&quot;)&#10;            &#10;            # 打印统计信息&#10;            print(&quot;\n计算结果统计:&quot;)&#10;            print(f&quot;序列长度范围: {results_df['length'].min()}-{results_df['length'].max()}&quot;)&#10;            print(f&quot;两亲性指数范围: {results_df['amphipathicity'].min():.3f}-{results_df['amphipathicity'].max():.3f}&quot;)&#10;            print(f&quot;净电荷范围: {results_df['net_charge_ph7.4'].min():.3f}-{results_df['net_charge_ph7.4'].max():.3f}&quot;)&#10;            print(f&quot;分子量范围: {results_df['molecular_weight'].min():.1f}-{results_df['molecular_weight'].max():.1f}&quot;)&#10;            print(f&quot;等电点范围: {results_df['isoelectric_point'].min():.2f}-{results_df['isoelectric_point'].max():.2f}&quot;)&#10;            print(f&quot;GRAVY值范围: {results_df['gravy'].min():.3f}-{results_df['gravy'].max():.3f}&quot;)&#10;            &#10;            if output_file:&#10;                results_df.to_csv(output_file, index=False)&#10;                print(f&quot;\n计算结果已保存到: {output_file}&quot;)&#10;            &#10;            return results_df&#10;        else:&#10;            print(&quot;没有有效的序列进行计算&quot;)&#10;            return pd.DataFrame()&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser(description='计算Vespa数据集中所有肽段的理化性质')&#10;    parser.add_argument('--input', help='输入的Vespa CSV文件路径',&#10;                        default='origin_data/Vespa.csv')&#10;    parser.add_argument('--output', help='输出文件路径',&#10;                       default='results/vespa_properties.csv')&#10;    parser.add_argument('--ph', type=float, default=7.4,&#10;                       help='计算净电荷的pH值 (默认: 7.4)')&#10;&#10;    args = parser.parse_args()&#10;    &#10;    # 确保输出目录存在&#10;    os.makedirs(os.path.dirname(args.output), exist_ok=True)&#10;    &#10;    calculator = VespaPropertiesCalculator()&#10;    results_df = calculator.calculate_all_properties(&#10;        input_file=args.input,&#10;        output_file=args.output,&#10;        ph=args.ph&#10;    )&#10;    &#10;    if results_df is not None and len(results_df) &gt; 0:&#10;        print(f&quot;\n计算成功完成！共计算了 {len(results_df)} 个序列的理化性质&quot;)&#10;        print(f&quot;结果已保存到: {args.output}&quot;)&#10;    else:&#10;        print(&quot;计算失败或没有有效的序列&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/experience_filter.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/experience_filter.py" />
              <option name="originalContent" value="import pandas as pd&#10;from Bio.SeqUtils.ProtParam import ProteinAnalysis&#10;import os&#10;import argparse&#10;&#10;class ExperienceFilter:&#10;    def __init__(self):&#10;        self.hydrophobic_aa = set(['A', 'V', 'I', 'L', 'M', 'F', 'Y', 'W'])&#10;        self.hydrophilic_aa = set(['R', 'K', 'D', 'E', 'Q', 'N', 'H', 'S', 'T', 'G', 'P', 'C'])&#10;        self.positively_charged_aa = set(['R', 'K', 'H'])&#10;        self.negatively_charged_aa = set(['D', 'E'])&#10;&#10;    def calculate_amphipathicity(self, sequence):&#10;        hydrophobic_count = sum(1 for aa in sequence if aa in self.hydrophobic_aa)&#10;        hydrophilic_count = sum(1 for aa in sequence if aa in self.hydrophilic_aa)&#10;        total_count = len(sequence)&#10;        if total_count == 0:&#10;            return 0&#10;        hydrophobic_ratio = hydrophobic_count / total_count&#10;        hydrophilic_ratio = hydrophilic_count / total_count&#10;        if hydrophobic_ratio + hydrophilic_ratio == 0:&#10;            return 0&#10;        amphipathicity = 2 * hydrophobic_ratio * hydrophilic_ratio / (hydrophobic_ratio + hydrophilic_ratio)&#10;        return amphipathicity&#10;&#10;    def is_amphipathic(self, sequence, min_amphipathicity=0.3):&#10;        hydrophobic_count = sum(1 for aa in sequence if aa in self.hydrophobic_aa)&#10;        hydrophilic_count = sum(1 for aa in sequence if aa in self.hydrophilic_aa)&#10;        if hydrophobic_count == 0 or hydrophilic_count == 0:&#10;            return False&#10;        amphipathicity = self.calculate_amphipathicity(sequence)&#10;        return amphipathicity &gt;= min_amphipathicity&#10;&#10;    def check_length(self, sequence, min_length=15, max_length=17):&#10;        return min_length &lt;= len(sequence) &lt;= max_length&#10;&#10;    def calculate_net_charge_at_ph(self, sequence, ph=7.4):&#10;        try:&#10;            protein_analysis = ProteinAnalysis(sequence)&#10;            net_charge = protein_analysis.charge_at_pH(ph)&#10;            return net_charge&#10;        except Exception as e:&#10;            print(f&quot;Error calculating charge for sequence {sequence}: {e}&quot;)&#10;            return 0&#10;&#10;    def is_positively_charged(self, sequence, ph=7.4, min_charge=1.0):&#10;        net_charge = self.calculate_net_charge_at_ph(sequence, ph)&#10;        return net_charge &gt;= min_charge&#10;&#10;    def calculate_additional_properties(self, sequence):&#10;        try:&#10;            protein_analysis = ProteinAnalysis(sequence)&#10;            properties = {&#10;                'molecular_weight': protein_analysis.molecular_weight(),&#10;                'aromaticity': protein_analysis.aromaticity(),&#10;                'instability_index': protein_analysis.instability_index(),&#10;                'isoelectric_point': protein_analysis.isoelectric_point(),&#10;                'gravy': protein_analysis.gravy(),&#10;                'helix_fraction': protein_analysis.secondary_structure_fraction()[0],&#10;                'turn_fraction': protein_analysis.secondary_structure_fraction()[1],&#10;                'sheet_fraction': protein_analysis.secondary_structure_fraction()[2]&#10;            }&#10;            return properties&#10;        except Exception as e:&#10;            print(f&quot;Error calculating properties for sequence {sequence}: {e}&quot;)&#10;            return {}&#10;&#10;    def filter_peptides(self, input_file, output_file=None,&#10;                       min_amphipathicity=0.3,&#10;                       min_length=15, max_length=17,&#10;                       ph=7.4, min_charge=1.0):&#10;        if not os.path.exists(input_file):&#10;            print(f&quot;输入文件 {input_file} 不存在&quot;)&#10;            return None&#10;&#10;        df = pd.read_csv(input_file)&#10;&#10;        if 'Sequence' not in df.columns:&#10;            print(&quot;输入文件中没有找到序列列，请确保列名为'Sequence'&quot;)&#10;            return None&#10;&#10;        print(f&quot;开始筛选，共有 {len(df)} 个候选肽&quot;)&#10;&#10;        filtered_results = []&#10;&#10;        for idx, row in df.iterrows():&#10;            sequence = str(row['Sequence']).strip().upper()&#10;            if not sequence or not sequence.isalpha():&#10;                continue&#10;&#10;            length_pass = self.check_length(sequence, min_length, max_length)&#10;            amphipathic_pass = self.is_amphipathic(sequence, min_amphipathicity)&#10;            charge_pass = self.is_positively_charged(sequence, ph, min_charge)&#10;&#10;            if length_pass and amphipathic_pass and charge_pass:&#10;                properties = self.calculate_additional_properties(sequence)&#10;                result = {&#10;                    'Sequence': sequence,&#10;                    'length': len(sequence),&#10;                    'amphipathicity': self.calculate_amphipathicity(sequence),&#10;                    'net_charge_ph7.4': self.calculate_net_charge_at_ph(sequence, ph),&#10;                    'passes_length': length_pass,&#10;                    'passes_amphipathicity': amphipathic_pass,&#10;                    'passes_charge': charge_pass,&#10;                    'overall_pass': True&#10;                }&#10;                for col in df.columns:&#10;                    if col != 'Sequence' and col not in result:&#10;                        result[col] = row[col]&#10;                result.update(properties)&#10;                filtered_results.append(result)&#10;&#10;        if filtered_results:&#10;            filtered_df = pd.DataFrame(filtered_results)&#10;            print(f&quot;筛选完成，通过筛选的肽段数量: {len(filtered_df)}&quot;)&#10;            print(f&quot;筛选通过率: {len(filtered_df)/len(df)*100:.2f}%&quot;)&#10;            print(&quot;\n筛选结果统计:&quot;)&#10;            print(f&quot;长度范围: {filtered_df['length'].min()}-{filtered_df['length'].max()}&quot;)&#10;            print(f&quot;两亲性指数范围: {filtered_df['amphipathicity'].min():.3f}-{filtered_df['amphipathicity'].max():.3f}&quot;)&#10;            print(f&quot;净电荷范围: {filtered_df['net_charge_ph7.4'].min():.3f}-{filtered_df['net_charge_ph7.4'].max():.3f}&quot;)&#10;            if output_file:&#10;                filtered_df.to_csv(output_file, index=False)&#10;                print(f&quot;筛选结果已保存到: {output_file}&quot;)&#10;            return filtered_df&#10;        else:&#10;            print(&quot;没有肽段通过所有筛选条件&quot;)&#10;            return pd.DataFrame()&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser(description='对候选AMP进行经验筛选')&#10;    parser.add_argument('--input', help='输入的候选肽CSV文件路径',&#10;                        default='results/generated_peptides/candidate_amps.csv')&#10;    parser.add_argument('--output', help='输出文件路径',&#10;                       default='results/generated_peptides/potential_amps.csv')&#10;    parser.add_argument('--min_amphipathicity', type=float, default=0.3,&#10;                       help='最小两亲性指数 (默认: 0.3)')&#10;    parser.add_argument('--min_length', type=int, default=15,&#10;                       help='最小序列长度 (默认: 15)')&#10;    parser.add_argument('--max_length', type=int, default=18,&#10;                       help='最大序列长度 (默认: 8)')&#10;    parser.add_argument('--ph', type=float, default=7.4,&#10;                       help='计算净电荷的pH值 (默认: 7.4)')&#10;    parser.add_argument('--min_charge', type=float, default=1.0,&#10;                       help='最小净正电荷 (默认: 1.0)')&#10;&#10;    args = parser.parse_args()&#10;    os.makedirs(os.path.dirname(args.output), exist_ok=True)&#10;    filter_obj = ExperienceFilter()&#10;    filtered_df = filter_obj.filter_peptides(&#10;        input_file=args.input,&#10;        output_file=args.output,&#10;        min_amphipathicity=args.min_amphipathicity,&#10;        min_length=args.min_length,&#10;        max_length=args.max_length,&#10;        ph=args.ph,&#10;        min_charge=args.min_charge&#10;    )&#10;    if filtered_df is not None and len(filtered_df) &gt; 0:&#10;        print(f&quot;\n筛选成功完成！共筛选出 {len(filtered_df)} 个符合条件的AMP候选肽&quot;)&#10;    else:&#10;        print(&quot;筛选未发现符合条件的肽段&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
              <option name="updatedContent" value="import pandas as pd&#10;from Bio.SeqUtils.ProtParam import ProteinAnalysis&#10;import os&#10;import argparse&#10;&#10;class ExperienceFilter:&#10;    def __init__(self):&#10;        self.hydrophobic_aa = set(['A', 'V', 'I', 'L', 'M', 'F', 'Y', 'W'])&#10;        self.hydrophilic_aa = set(['R', 'K', 'D', 'E', 'Q', 'N', 'H', 'S', 'T', 'G', 'P', 'C'])&#10;        self.positively_charged_aa = set(['R', 'K', 'H'])&#10;        self.negatively_charged_aa = set(['D', 'E'])&#10;&#10;    def calculate_amphipathicity(self, sequence):&#10;        hydrophobic_count = sum(1 for aa in sequence if aa in self.hydrophobic_aa)&#10;        hydrophilic_count = sum(1 for aa in sequence if aa in self.hydrophilic_aa)&#10;        total_count = len(sequence)&#10;        if total_count == 0:&#10;            return 0&#10;        hydrophobic_ratio = hydrophobic_count / total_count&#10;        hydrophilic_ratio = hydrophilic_count / total_count&#10;        if hydrophobic_ratio + hydrophilic_ratio == 0:&#10;            return 0&#10;        amphipathicity = 2 * hydrophobic_ratio * hydrophilic_ratio / (hydrophobic_ratio + hydrophilic_ratio)&#10;        return amphipathicity&#10;&#10;    def is_amphipathic(self, sequence, min_amphipathicity=0.35):&#10;        hydrophobic_count = sum(1 for aa in sequence if aa in self.hydrophobic_aa)&#10;        hydrophilic_count = sum(1 for aa in sequence if aa in self.hydrophilic_aa)&#10;        if hydrophobic_count == 0 or hydrophilic_count == 0:&#10;            return False&#10;        amphipathicity = self.calculate_amphipathicity(sequence)&#10;        return amphipathicity &gt;= min_amphipathicity&#10;&#10;    def check_length(self, sequence, min_length=15, max_length=18):&#10;        return min_length &lt;= len(sequence) &lt;= max_length&#10;&#10;    def calculate_net_charge_at_ph(self, sequence, ph=7.4):&#10;        try:&#10;            protein_analysis = ProteinAnalysis(sequence)&#10;            net_charge = protein_analysis.charge_at_pH(ph)&#10;            return net_charge&#10;        except Exception as e:&#10;            print(f&quot;Error calculating charge for sequence {sequence}: {e}&quot;)&#10;            return 0&#10;&#10;    def is_positively_charged(self, sequence, ph=7.4, min_charge=3.5):&#10;        net_charge = self.calculate_net_charge_at_ph(sequence, ph)&#10;        return net_charge &gt;= min_charge&#10;&#10;    def calculate_additional_properties(self, sequence):&#10;        try:&#10;            protein_analysis = ProteinAnalysis(sequence)&#10;            properties = {&#10;                'molecular_weight': protein_analysis.molecular_weight(),&#10;                'aromaticity': protein_analysis.aromaticity(),&#10;                'instability_index': protein_analysis.instability_index(),&#10;                'isoelectric_point': protein_analysis.isoelectric_point(),&#10;                'gravy': protein_analysis.gravy(),&#10;                'helix_fraction': protein_analysis.secondary_structure_fraction()[0],&#10;                'turn_fraction': protein_analysis.secondary_structure_fraction()[1],&#10;                'sheet_fraction': protein_analysis.secondary_structure_fraction()[2]&#10;            }&#10;            return properties&#10;        except Exception as e:&#10;            print(f&quot;Error calculating properties for sequence {sequence}: {e}&quot;)&#10;            return {}&#10;&#10;    def filter_peptides(self, input_file, output_file=None,&#10;                       min_amphipathicity=0.35,&#10;                       min_length=15, max_length=18,&#10;                       ph=7.4, min_charge=3.5):&#10;        if not os.path.exists(input_file):&#10;            print(f&quot;输入文件 {input_file} 不存在&quot;)&#10;            return None&#10;&#10;        df = pd.read_csv(input_file)&#10;&#10;        if 'Sequence' not in df.columns:&#10;            print(&quot;输入文件中没有找到序列列，请确保列名为'Sequence'&quot;)&#10;            return None&#10;&#10;        print(f&quot;开始筛选，共有 {len(df)} 个候选肽&quot;)&#10;        print(&quot;筛选条件 (基于Vespa数据集特征):&quot;)&#10;        print(f&quot;  序列长度: {min_length}-{max_length}&quot;)&#10;        print(f&quot;  两亲性指数: ≥{min_amphipathicity}&quot;)&#10;        print(f&quot;  净电荷 (pH {ph}): ≥{min_charge}&quot;)&#10;&#10;        filtered_results = []&#10;&#10;        for idx, row in df.iterrows():&#10;            sequence = str(row['Sequence']).strip().upper()&#10;            if not sequence or not sequence.isalpha():&#10;                continue&#10;&#10;            length_pass = self.check_length(sequence, min_length, max_length)&#10;            amphipathic_pass = self.is_amphipathic(sequence, min_amphipathicity)&#10;            charge_pass = self.is_positively_charged(sequence, ph, min_charge)&#10;&#10;            if length_pass and amphipathic_pass and charge_pass:&#10;                properties = self.calculate_additional_properties(sequence)&#10;                result = {&#10;                    'Sequence': sequence,&#10;                    'length': len(sequence),&#10;                    'amphipathicity': self.calculate_amphipathicity(sequence),&#10;                    'net_charge_ph7.4': self.calculate_net_charge_at_ph(sequence, ph),&#10;                    'passes_length': length_pass,&#10;                    'passes_amphipathicity': amphipathic_pass,&#10;                    'passes_charge': charge_pass,&#10;                    'overall_pass': True&#10;                }&#10;                for col in df.columns:&#10;                    if col != 'Sequence' and col not in result:&#10;                        result[col] = row[col]&#10;                result.update(properties)&#10;                filtered_results.append(result)&#10;&#10;        if filtered_results:&#10;            filtered_df = pd.DataFrame(filtered_results)&#10;            print(f&quot;筛选完成，通过筛选的肽段数量: {len(filtered_df)}&quot;)&#10;            print(f&quot;筛选通过率: {len(filtered_df)/len(df)*100:.2f}%&quot;)&#10;            print(&quot;\n筛选结果统计:&quot;)&#10;            print(f&quot;长度范围: {filtered_df['length'].min()}-{filtered_df['length'].max()}&quot;)&#10;            print(f&quot;两亲性指数范围: {filtered_df['amphipathicity'].min():.3f}-{filtered_df['amphipathicity'].max():.3f}&quot;)&#10;            print(f&quot;净电荷范围: {filtered_df['net_charge_ph7.4'].min():.3f}-{filtered_df['net_charge_ph7.4'].max():.3f}&quot;)&#10;            if output_file:&#10;                filtered_df.to_csv(output_file, index=False)&#10;                print(f&quot;筛选结果已保存到: {output_file}&quot;)&#10;            return filtered_df&#10;        else:&#10;            print(&quot;没有肽段通过所有筛选条件&quot;)&#10;            return pd.DataFrame()&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser(description='对候选AMP进行经验筛选 (基于Vespa数据集特征)')&#10;    parser.add_argument('--input', help='输入的候选肽CSV文件路径',&#10;                        default='results/generated_peptides/candidate_amps.csv')&#10;    parser.add_argument('--output', help='输出文件路径',&#10;                       default='results/generated_peptides/potential_amps.csv')&#10;    parser.add_argument('--min_amphipathicity', type=float, default=0.35,&#10;                       help='最小两亲性指数 (默认: 0.35)')&#10;    parser.add_argument('--min_length', type=int, default=15,&#10;                       help='最小序列长度 (默认: 15)')&#10;    parser.add_argument('--max_length', type=int, default=18,&#10;                       help='最大序列长度 (默认: 18)')&#10;    parser.add_argument('--ph', type=float, default=7.4,&#10;                       help='计算净电荷的pH值 (默认: 7.4)')&#10;    parser.add_argument('--min_charge', type=float, default=3.5,&#10;                       help='最小净正电荷 (默认: 3.5)')&#10;&#10;    args = parser.parse_args()&#10;    os.makedirs(os.path.dirname(args.output), exist_ok=True)&#10;    filter_obj = ExperienceFilter()&#10;    filtered_df = filter_obj.filter_peptides(&#10;        input_file=args.input,&#10;        output_file=args.output,&#10;        min_amphipathicity=args.min_amphipathicity,&#10;        min_length=args.min_length,&#10;        max_length=args.max_length,&#10;        ph=args.ph,&#10;        min_charge=args.min_charge&#10;    )&#10;    if filtered_df is not None and len(filtered_df) &gt; 0:&#10;        print(f&quot;\n筛选成功完成！共筛选出 {len(filtered_df)} 个符合条件的AMP候选肽&quot;)&#10;        print(&quot;筛选的肽段具有与Vespa数据集相似的理化性质特征&quot;)&#10;    else:&#10;        print(&quot;筛选未发现符合条件的肽段&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/experience_filter_improved.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/experience_filter_improved.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;改进的经验筛选脚本 - 使用Biopython进行更准确的计算&#10;筛选条件：&#10;1. 具有两亲性（疏水性和亲水性氨基酸的平衡）&#10;2. 序列长度为15-17个氨基酸&#10;3. 在生理pH值下净正电荷&#10;&#10;Author: GitHub Copilot&#10;Date: 2025-01-04&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import numpy as np&#10;import os&#10;import argparse&#10;&#10;try:&#10;    from Bio.SeqUtils.ProtParam import ProteinAnalysis&#10;    from Bio.SeqUtils import molecular_weight&#10;    from Bio.Seq import Seq&#10;    BIOPYTHON_AVAILABLE = True&#10;except ImportError:&#10;    BIOPYTHON_AVAILABLE = False&#10;    print(&quot;警告: Biopython未安装，将使用简化计算方法&quot;)&#10;&#10;&#10;class ImprovedExperienceFilter:&#10;    def __init__(self):&#10;        # Kyte-Doolittle疏水性指数（标准化）&#10;        self.kyte_doolittle = {&#10;            'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5,&#10;            'Q': -3.5, 'E': -3.5, 'G': -0.4, 'H': -3.2, 'I': 4.5,&#10;            'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6,&#10;            'S': -0.8, 'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2&#10;        }&#10;        &#10;        # 氨基酸电荷（在pH 7.0时）&#10;        self.aa_charges_ph7 = {&#10;            'R': 1.0, 'K': 1.0, 'H': 0.1, 'D': -1.0, 'E': -1.0,&#10;            'C': 0.0, 'Y': 0.0  # 其他氨基酸在生理pH下基本不带电&#10;        }&#10;        &#10;        # 氨基酸分类&#10;        self.hydrophobic_aa = set(['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V', 'C'])&#10;        self.hydrophilic_aa = set(['R', 'N', 'D', 'Q', 'E', 'H', 'K', 'S', 'T'])&#10;        self.charged_aa = set(['R', 'K', 'H', 'D', 'E'])&#10;        self.polar_aa = set(['N', 'D', 'Q', 'E', 'H', 'K', 'S', 'T', 'R', 'Y', 'C'])&#10;    &#10;    def calculate_length_filter(self, sequence):&#10;        &quot;&quot;&quot;检查序列长度&quot;&quot;&quot;&#10;        return 15 &lt;= len(sequence) &lt;= 17&#10;    &#10;    def calculate_net_charge_biopython(self, sequence, ph=7.4):&#10;        &quot;&quot;&quot;使用Biopython计算净电荷&quot;&quot;&quot;&#10;        if not BIOPYTHON_AVAILABLE:&#10;            return self.calculate_net_charge_simple(sequence, ph)&#10;        &#10;        try:&#10;            protein_analysis = ProteinAnalysis(str(sequence))&#10;            return protein_analysis.charge_at_pH(ph)&#10;        except Exception:&#10;            return self.calculate_net_charge_simple(sequence, ph)&#10;    &#10;    def calculate_net_charge_simple(self, sequence, ph=7.4):&#10;        &quot;&quot;&quot;简化的净电荷计算（备用方法）&quot;&quot;&quot;&#10;        net_charge = 0&#10;        for aa in sequence:&#10;            if aa == 'R':&#10;                net_charge += 1.0  # 精氨酸在生理pH下完全质子化&#10;            elif aa == 'K':&#10;                net_charge += 1.0  # 赖氨酸在生理pH下完全质子化&#10;            elif aa == 'H':&#10;                # 组氨酸的pKa约为6.0，在pH 7.4时部分质子化&#10;                net_charge += 1 / (1 + 10**(ph - 6.0))&#10;            elif aa == 'D':&#10;                net_charge -= 1.0  # 天冬氨酸在生理pH下完全去质子化&#10;            elif aa == 'E':&#10;                net_charge -= 1.0  # 谷氨酸在生理pH下完全去质子化&#10;        return net_charge&#10;    &#10;    def calculate_hydrophobicity_biopython(self, sequence):&#10;        &quot;&quot;&quot;使用Biopython计算疏水性&quot;&quot;&quot;&#10;        if not BIOPYTHON_AVAILABLE:&#10;            return self.calculate_hydrophobicity_simple(sequence)&#10;        &#10;        try:&#10;            protein_analysis = ProteinAnalysis(str(sequence))&#10;            # 获取Kyte-Doolittle疏水性值的平均值&#10;            hydrophobicity = protein_analysis.protein_scale(&#10;                param_dict=self.kyte_doolittle, window=len(sequence)&#10;            )[0]&#10;            return hydrophobicity&#10;        except Exception:&#10;            return self.calculate_hydrophobicity_simple(sequence)&#10;    &#10;    def calculate_hydrophobicity_simple(self, sequence):&#10;        &quot;&quot;&quot;简化的疏水性计算&quot;&quot;&quot;&#10;        total_hydrophobicity = sum(self.kyte_doolittle.get(aa, 0) for aa in sequence)&#10;        return total_hydrophobicity / len(sequence)&#10;    &#10;    def calculate_amphiphilicity_advanced(self, sequence):&#10;        &quot;&quot;&quot;计算高级两亲性指标&quot;&quot;&quot;&#10;        # 基本统计&#10;        hydrophobic_count = sum(1 for aa in sequence if aa in self.hydrophobic_aa)&#10;        hydrophilic_count = sum(1 for aa in sequence if aa in self.hydrophilic_aa)&#10;        charged_count = sum(1 for aa in sequence if aa in self.charged_aa)&#10;        polar_count = sum(1 for aa in sequence if aa in self.polar_aa)&#10;        &#10;        total_length = len(sequence)&#10;        &#10;        # 计算比例&#10;        hydrophobic_ratio = hydrophobic_count / total_length&#10;        hydrophilic_ratio = hydrophilic_count / total_length&#10;        charged_ratio = charged_count / total_length&#10;        polar_ratio = polar_count / total_length&#10;        &#10;        # 获取平均疏水性&#10;        avg_hydrophobicity = self.calculate_hydrophobicity_biopython(sequence)&#10;        &#10;        # 计算两亲性指标&#10;        if hydrophobic_count == 0 or hydrophilic_count == 0:&#10;            amphiphilicity_score = 0&#10;        else:&#10;            # 方法1: 平衡度指标 (0-1)&#10;            balance = 1 - abs(hydrophobic_ratio - hydrophilic_ratio)&#10;            &#10;            # 方法2: 多样性指标 - 考虑疏水、亲水、带电的分布&#10;            diversity = min(hydrophobic_ratio, hydrophilic_ratio) * 2&#10;            &#10;            # 方法3: 基于疏水性分布的两亲性&#10;            # 理想的AMP应该有适中的疏水性（不太高不太低）&#10;            hydrophobicity_score = 1 - abs(avg_hydrophobicity) / 4.5  # 标准化到0-1&#10;            hydrophobicity_score = max(0, hydrophobicity_score)&#10;            &#10;            # 综合两亲性得分&#10;            amphiphilicity_score = (balance * 0.4 + diversity * 0.4 + hydrophobicity_score * 0.2)&#10;        &#10;        return {&#10;            'amphiphilicity_score': amphiphilicity_score,&#10;            'hydrophobic_ratio': hydrophobic_ratio,&#10;            'hydrophilic_ratio': hydrophilic_ratio,&#10;            'charged_ratio': charged_ratio,&#10;            'polar_ratio': polar_ratio,&#10;            'avg_hydrophobicity': avg_hydrophobicity,&#10;            'hydrophobic_count': hydrophobic_count,&#10;            'hydrophilic_count': hydrophilic_count,&#10;            'charged_count': charged_count&#10;        }&#10;    &#10;    def is_amphiphilic_advanced(self, sequence, min_amphiphilicity=0.3):&#10;        &quot;&quot;&quot;高级两亲性判断&quot;&quot;&quot;&#10;        amphiphilicity_data = self.calculate_amphiphilicity_advanced(sequence)&#10;        &#10;        # 条件1: 两亲性得分达标&#10;        score_pass = amphiphilicity_data['amphiphilicity_score'] &gt;= min_amphiphilicity&#10;        &#10;        # 条件2: 疏水性和亲水性氨基酸都要存在&#10;        both_present = (amphiphilicity_data['hydrophobic_count'] &gt; 0 and &#10;                       amphiphilicity_data['hydrophilic_count'] &gt; 0)&#10;        &#10;        # 条件3: 疏水性比例在合理范围内（20%-70%）&#10;        hydrophobic_balance = 0.2 &lt;= amphiphilicity_data['hydrophobic_ratio'] &lt;= 0.7&#10;        &#10;        # 条件4: 至少有一些带电氨基酸（用于抗菌活性）&#10;        has_charge = amphiphilicity_data['charged_count'] &gt;= 2&#10;        &#10;        # 条件5: 平均疏水性不能太极端&#10;        hydrophobicity_reasonable = -2.0 &lt;= amphiphilicity_data['avg_hydrophobicity'] &lt;= 2.0&#10;        &#10;        return (score_pass and both_present and hydrophobic_balance and &#10;                has_charge and hydrophobicity_reasonable)&#10;    &#10;    def calculate_additional_properties(self, sequence):&#10;        &quot;&quot;&quot;计算额外的蛋白质性质&quot;&quot;&quot;&#10;        additional_props = {}&#10;        &#10;        if BIOPYTHON_AVAILABLE:&#10;            try:&#10;                protein_analysis = ProteinAnalysis(str(sequence))&#10;                &#10;                # 分子量&#10;                additional_props['molecular_weight'] = protein_analysis.molecular_weight()&#10;                &#10;                # 等电点&#10;                additional_props['isoelectric_point'] = protein_analysis.isoelectric_point()&#10;                &#10;                # 芳香族氨基酸含量&#10;                additional_props['aromaticity'] = protein_analysis.aromaticity()&#10;                &#10;                # 不稳定性指数&#10;                additional_props['instability_index'] = protein_analysis.instability_index()&#10;                &#10;            except Exception as e:&#10;                print(f&quot;计算额外性质时出错: {e}&quot;)&#10;                additional_props = {&#10;                    'molecular_weight': None,&#10;                    'isoelectric_point': None,&#10;                    'aromaticity': None,&#10;                    'instability_index': None&#10;                }&#10;        else:&#10;            additional_props = {&#10;                'molecular_weight': None,&#10;                'isoelectric_point': None,&#10;                'aromaticity': None,&#10;                'instability_index': None&#10;            }&#10;        &#10;        return additional_props&#10;    &#10;    def apply_filters(self, sequences_df, &#10;                     min_net_charge=1, &#10;                     min_amphiphilicity=0.3,&#10;                     ph=7.4):&#10;        &quot;&quot;&quot;应用所有筛选条件&quot;&quot;&quot;&#10;        &#10;        results = []&#10;        &#10;        for idx, row in sequences_df.iterrows():&#10;            sequence = row['sequence'] if 'sequence' in row else row['Sequence']&#10;            &#10;            # 应用三个主要筛选条件&#10;            length_pass = self.calculate_length_filter(sequence)&#10;            net_charge = self.calculate_net_charge_biopython(sequence, ph)&#10;            charge_pass = net_charge &gt;= min_net_charge&#10;            amphiphilic_pass = self.is_amphiphilic_advanced(sequence, min_amphiphilicity)&#10;            &#10;            # 计算详细的两亲性信息&#10;            amphiphilicity_data = self.calculate_amphiphilicity_advanced(sequence)&#10;            &#10;            # 计算额外性质&#10;            additional_props = self.calculate_additional_properties(sequence)&#10;            &#10;            # 记录结果&#10;            result = {&#10;                'sequence': sequence,&#10;                'length': len(sequence),&#10;                'net_charge': net_charge,&#10;                'amphiphilicity_score': amphiphilicity_data['amphiphilicity_score'],&#10;                'hydrophobic_ratio': amphiphilicity_data['hydrophobic_ratio'],&#10;                'hydrophilic_ratio': amphiphilicity_data['hydrophilic_ratio'],&#10;                'charged_ratio': amphiphilicity_data['charged_ratio'],&#10;                'avg_hydrophobicity': amphiphilicity_data['avg_hydrophobicity'],&#10;                'length_pass': length_pass,&#10;                'charge_pass': charge_pass,&#10;                'amphiphilic_pass': amphiphilic_pass,&#10;                'all_pass': length_pass and charge_pass and amphiphilic_pass,&#10;                **additional_props&#10;            }&#10;            &#10;            # 保留原始数据的其他列&#10;            for col in row.index:&#10;                if col.lower() not in ['sequence']:&#10;                    result[f'original_{col}'] = row[col]&#10;            &#10;            results.append(result)&#10;        &#10;        return pd.DataFrame(results)&#10;    &#10;    def filter_and_save(self, input_file, output_file, &#10;                       min_net_charge=1, &#10;                       min_amphiphilicity=0.3,&#10;                       ph=7.4):&#10;        &quot;&quot;&quot;读取文件，应用筛选，保存结果&quot;&quot;&quot;&#10;        &#10;        # 检查Biopython&#10;        if BIOPYTHON_AVAILABLE:&#10;            print(&quot;使用Biopython进行精确计算&quot;)&#10;        else:&#10;            print(&quot;使用简化方法进行计算（建议安装Biopython获得更准确结果）&quot;)&#10;        &#10;        # 读取输入文件&#10;        if not os.path.exists(input_file):&#10;            raise FileNotFoundError(f&quot;输入文件不存在: {input_file}&quot;)&#10;        &#10;        try:&#10;            df = pd.read_csv(input_file)&#10;            print(f&quot;成功读取输入文件，共{len(df)}条序列&quot;)&#10;        except Exception as e:&#10;            raise Exception(f&quot;读取输入文件失败: {e}&quot;)&#10;        &#10;        # 应用筛选&#10;        results_df = self.apply_filters(df, min_net_charge, min_amphiphilicity, ph)&#10;        &#10;        # 统计结果&#10;        total_sequences = len(results_df)&#10;        passed_sequences = len(results_df[results_df['all_pass'] == True])&#10;        &#10;        print(f&quot;\n=== 筛选结果统计 ===&quot;)&#10;        print(f&quot;总序列数: {total_sequences}&quot;)&#10;        print(f&quot;通过长度筛选 (15-17 aa): {len(results_df[results_df['length_pass'] == True])}&quot;)&#10;        print(f&quot;通过电荷筛选 (净正电荷 &gt;= {min_net_charge}): {len(results_df[results_df['charge_pass'] == True])}&quot;)&#10;        print(f&quot;通过两亲性筛选 (得分 &gt;= {min_amphiphilicity}): {len(results_df[results_df['amphiphilic_pass'] == True])}&quot;)&#10;        print(f&quot;通过所有筛选条件: {passed_sequences}&quot;)&#10;        print(f&quot;筛选通过率: {passed_sequences/total_sequences*100:.2f}%&quot;)&#10;        &#10;        # 显示一些统计信息&#10;        if BIOPYTHON_AVAILABLE and len(results_df) &gt; 0:&#10;            print(f&quot;\n=== 序列性质统计 ===&quot;)&#10;            print(f&quot;平均分子量: {results_df['molecular_weight'].mean():.1f} Da&quot;)&#10;            print(f&quot;平均等电点: {results_df['isoelectric_point'].mean():.2f}&quot;)&#10;            print(f&quot;平均芳香族含量: {results_df['aromaticity'].mean():.3f}&quot;)&#10;        &#10;        # 保存所有结果&#10;        results_df.to_csv(output_file, index=False)&#10;        print(f&quot;\n详细结果已保存到: {output_file}&quot;)&#10;        &#10;        # 保存仅通过筛选的序列&#10;        passed_df = results_df[results_df['all_pass'] == True]&#10;        if len(passed_df) &gt; 0:&#10;            passed_output_file = output_file.replace('.csv', '_passed_only.csv')&#10;            passed_df.to_csv(passed_output_file, index=False)&#10;            print(f&quot;通过筛选的序列已保存到: {passed_output_file}&quot;)&#10;        &#10;        return results_df&#10;&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser(description='改进的经验筛选抗菌肽候选序列')&#10;    parser.add_argument('--input', '-i', &#10;                       default='results/generated_peptides/candidate_amps.csv',&#10;                       help='输入CSV文件路径')&#10;    parser.add_argument('--output', '-o',&#10;                       default='results/generated_peptides/potential_amps.csv',&#10;                       help='输出CSV文件路径')&#10;    parser.add_argument('--min_charge', type=float, default=1.0,&#10;                       help='最小净正电荷 (默认: 1.0)')&#10;    parser.add_argument('--min_amphiphilicity', type=float, default=0.3,&#10;                       help='最小两亲性得分 (默认: 0.3)')&#10;    parser.add_argument('--ph', type=float, default=7.4,&#10;                       help='pH值 (默认: 7.4)')&#10;    &#10;    args = parser.parse_args()&#10;    &#10;    # 创建输出目录&#10;    os.makedirs(os.path.dirname(args.output), exist_ok=True)&#10;    &#10;    # 执行筛选&#10;    filter_engine = ImprovedExperienceFilter()&#10;    &#10;    try:&#10;        results_df = filter_engine.filter_and_save(&#10;            input_file=args.input,&#10;            output_file=args.output,&#10;            min_net_charge=args.min_charge,&#10;            min_amphiphilicity=args.min_amphiphilicity,&#10;            ph=args.ph&#10;        )&#10;        &#10;        print(f&quot;\n经验筛选完成！&quot;)&#10;        &#10;    except Exception as e:&#10;        print(f&quot;筛选过程中发生错误: {e}&quot;)&#10;        return 1&#10;    &#10;    return 0&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    sys.exit(main())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/origin_data/blast.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/origin_data/blast.py" />
              <option name="originalContent" value="import pandas as pd&#10;import time&#10;import os&#10;from Bio.Blast import NCBIWWW, NCBIXML&#10;&#10;# === 1. 读取本地 CSV 文件 ===&#10;INPUT_FILE = &quot;Vespa.csv&quot;&#10;&#10;# 检查输入文件是否存在&#10;if not os.path.exists(INPUT_FILE):&#10;    print(f&quot;错误：输入文件 {INPUT_FILE} 不存在！&quot;)&#10;    exit(1)&#10;&#10;try:&#10;    df = pd.read_csv(INPUT_FILE)&#10;    print(f&quot;成功读取 {len(df)} 条记录&quot;)&#10;except Exception as e:&#10;    print(f&quot;读取文件失败：{e}&quot;)&#10;    exit(1)&#10;&#10;# === 2. 运行 NCBI BLASTp 在线比对（可替换为 DRAMP/APD3 API 如开放） ===&#10;def run_ncbi_blast(sequence):&#10;    try:&#10;        print(f&quot;  正在进行BLAST查询...&quot;)&#10;        result_handle = NCBIWWW.qblast(&quot;blastp&quot;, &quot;nr&quot;, sequence, format_type=&quot;XML&quot;, expect=10.0, hitlist_size=5)&#10;        blast_record = NCBIXML.read(result_handle)&#10;&#10;        if not blast_record.alignments:&#10;            return (&quot;无明显匹配&quot;, &quot;&lt;30%&quot;, &quot;无 MIC 报道&quot;, &quot;—&quot;, &quot;NCBI BLAST&quot;)&#10;&#10;        top_hit = blast_record.alignments[0]&#10;        hit_id = top_hit.hit_id&#10;        title = top_hit.title&#10;        score = top_hit.hsps[0].score&#10;        identity = top_hit.hsps[0].identities&#10;        align_len = top_hit.hsps[0].align_length&#10;        percent_identity = round(identity / align_len * 100, 1)&#10;&#10;        # 暂无 MIC 数据可查询（本地模拟）&#10;        mic_info = &quot;未知&quot;&#10;        target_bacteria = &quot;可能存在相关数据&quot;&#10;&#10;        return (title, f&quot;{percent_identity}%&quot;, mic_info, target_bacteria, &quot;NCBI BLAST&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;  BLAST查询失败：{e}&quot;)&#10;        return (&quot;查询失败&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, str(e))&#10;&#10;# === 3. 批量处理并记录结果 ===&#10;results = []&#10;total_records = len(df)&#10;&#10;for idx, row in df.iterrows():&#10;    name = row[&quot;Name&quot;]&#10;    seq = row[&quot;Sequence&quot;]&#10;    current_index = int(idx) if isinstance(idx, (int, float)) else idx&#10;    print(f&quot;查询进度 {current_index + 1}/{total_records}: {name} -&gt; {seq}&quot;)&#10;&#10;    try:&#10;        match, identity, mic, target, source = run_ncbi_blast(seq)&#10;        results.append([name, seq, match, identity, mic, target, source])&#10;        print(f&quot;  完成：相似度 {identity}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;  处理失败：{e}&quot;)&#10;        results.append([name, seq, &quot;处理失败&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, str(e)])&#10;&#10;    # 控制请求频率，避免IP封锁&#10;    if current_index &lt; total_records - 1:  # 最后一个不需要等待&#10;        print(f&quot;  等待10秒...&quot;)&#10;        time.sleep(10)&#10;&#10;# === 4. 保存结果为文件 ===&#10;output_df = pd.DataFrame(results, columns=[&quot;Name&quot;, &quot;Sequence&quot;, &quot;Matched_Peptide&quot;, &quot;Similarity (%)&quot;, &quot;Known_MIC_Info&quot;, &quot;Target_Bacteria&quot;, &quot;Source_Database&quot;])&#10;&#10;try:&#10;    # 修复：使用正确的文件扩展名&#10;    output_file = &quot;vespa_peptide_blast_results.xlsx&quot;&#10;    output_df.to_excel(output_file, index=False)&#10;    print(f&quot;比对完成，结果已保存为 {output_file}&quot;)&#10;&#10;    # 同时保存为CSV格式作为备份&#10;    csv_file = &quot;vespa_peptide_blast_results.csv&quot;&#10;    output_df.to_csv(csv_file, index=False)&#10;    print(f&quot;CSV格式备份已保存为 {csv_file}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;保存Excel文件失败：{e}&quot;)&#10;    # 如果Excel保存失败，至少保存为CSV&#10;    try:&#10;        csv_file = &quot;vespa_peptide_blast_results.csv&quot;&#10;        output_df.to_csv(csv_file, index=False)&#10;        print(f&quot;已保存为CSV格式：{csv_file}&quot;)&#10;    except Exception as csv_e:&#10;        print(f&quot;CSV保存也失败：{csv_e}&quot;)&#10;" />
              <option name="updatedContent" value="import pandas as pd&#10;import time&#10;import os&#10;from Bio.Blast import NCBIWWW, NCBIXML&#10;&#10;# === 1. 读取本地 CSV 文件 ===&#10;INPUT_FILE = &quot;Vespa.csv&quot;&#10;&#10;# 检查输入文件是否存在&#10;if not os.path.exists(INPUT_FILE):&#10;    print(f&quot;错误：输入文件 {INPUT_FILE} 不存在！&quot;)&#10;    exit(1)&#10;&#10;try:&#10;    df = pd.read_csv(INPUT_FILE)&#10;    print(f&quot;成功读取 {len(df)} 条记录&quot;)&#10;except Exception as e:&#10;    print(f&quot;读取文件失败：{e}&quot;)&#10;    exit(1)&#10;&#10;# === 2. 运行 NCBI BLASTp 在线比对（可替换为 DRAMP/APD3 API 如开放） ===&#10;def run_ncbi_blast(sequence):&#10;    try:&#10;        print(f&quot;  正在进行BLAST查询...&quot;)&#10;        result_handle = NCBIWWW.qblast(&quot;blastp&quot;, &quot;nr&quot;, sequence, format_type=&quot;XML&quot;, expect=10.0, hitlist_size=5)&#10;        blast_record = NCBIXML.read(result_handle)&#10;&#10;        if not blast_record.alignments:&#10;            return (&quot;无明显匹配&quot;, &quot;&lt;30%&quot;, &quot;无 MIC 报道&quot;, &quot;—&quot;, &quot;NCBI BLAST&quot;)&#10;&#10;        top_hit = blast_record.alignments[0]&#10;        hit_id = top_hit.hit_id&#10;        title = top_hit.title&#10;        score = top_hit.hsps[0].score&#10;        identity = top_hit.hsps[0].identities&#10;        align_len = top_hit.hsps[0].align_length&#10;        percent_identity = round(identity / align_len * 100, 1)&#10;&#10;        # 暂无 MIC 数据可查询（本地模拟）&#10;        mic_info = &quot;未知&quot;&#10;        target_bacteria = &quot;可能存在相关数据&quot;&#10;&#10;        return (title, f&quot;{percent_identity}%&quot;, mic_info, target_bacteria, &quot;NCBI BLAST&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;  BLAST查询失败：{e}&quot;)&#10;        return (&quot;查询失败&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, str(e))&#10;&#10;# === 3. 批量处理并记录结果 ===&#10;results = []&#10;total_records = len(df)&#10;&#10;for idx, row in df.iterrows():&#10;    name = row[&quot;Name&quot;]&#10;    seq = row[&quot;Sequence&quot;]&#10;    current_index = int(idx) if isinstance(idx, (int, float)) else idx&#10;    print(f&quot;查询进度 {current_index + 1}/{total_records}: {name} -&gt; {seq}&quot;)&#10;&#10;    try:&#10;        match, identity, mic, target, source = run_ncbi_blast(seq)&#10;        results.append([name, seq, match, identity, mic, target, source])&#10;        print(f&quot;  完成：相似度 {identity}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;  处理失败：{e}&quot;)&#10;        results.append([name, seq, &quot;处理失败&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, str(e)])&#10;&#10;    # 控制请求频率，避免IP封锁&#10;    if current_index &lt; total_records - 1:  # 最后一个不需要等待&#10;        print(f&quot;  等待10秒...&quot;)&#10;        time.sleep(10)&#10;&#10;# === 4. 保存结果为文件 ===&#10;output_df = pd.DataFrame(results, columns=[&quot;Name&quot;, &quot;Sequence&quot;, &quot;Matched_Peptide&quot;, &quot;Similarity (%)&quot;, &quot;Known_MIC_Info&quot;, &quot;Target_Bacteria&quot;, &quot;Source_Database&quot;])&#10;&#10;try:&#10;    # 只保存为CSV格式&#10;    csv_file = &quot;vespa_peptide_blast_results.csv&quot;&#10;    output_df.to_csv(csv_file, index=False)&#10;    print(f&quot;比对完成，结果已保存为 {csv_file}&quot;)&#10;&#10;except Exception as e:&#10;    print(f&quot;保存CSV文件失败：{e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>